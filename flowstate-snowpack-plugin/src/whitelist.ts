import fs from "fs";
import path from "path";
import crypto from "crypto";
import {isPublicQuery, SQL} from "./sql.js";
import {groupBy, partition, makeRelativePath} from "./util.js";

const FILE_QUERY_ORDER = ["select", "update", "delete", "insert", "other"];

const sha256 = () => crypto.createHash("sha256");

export function writeWhitelists(targetDir: string, queries: SQL[]) {
    const outDir = path.join(targetDir, "flowstate");

    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir);
    }

    for (let sql of queries) {
        sql.fileName = makeRelativePath(targetDir, sql.fileName);
        for (let name in sql.validators) {
            if (sql.validators.hasOwnProperty(name)) {
                let val = sql.validators[name];
                val.fileName = makeRelativePath(targetDir, val.fileName);
            }
        }
        sql.referenced = sql.referenced.map(({line, fileName}) => ({line, fileName: makeRelativePath(targetDir, fileName)}));
    }

    const [pub, priv] = partition(queries, isPublicQuery);

    writeWhitelist(path.join(outDir, "whitelist-public.json"), pub);
    writeWhitelist(path.join(outDir, "whitelist-session.json"), priv);
}

function writeWhitelist(whitelistFile: string, queries: SQL[]) {
    if (queries.length === 0) {
        if (fs.existsSync(whitelistFile)) {
            fs.unlinkSync(whitelistFile);
        }
        return;
    }

    const grouped = groupBy(queries, sqlQueryType);

    // Move everything not in FILE_QUERY_ORDER into "other"
    let other = [];
    for (let key in grouped) {
        if (FILE_QUERY_ORDER.indexOf(key) < 0) {
            for (let q of grouped[key]) {
                other.push(q);
            }
        }
    }
    grouped["other"] = other;

    const ordered: Record<string, string | Record<string, SQL>> = {
        "comment": "File GENERATED BY Flow State, DO NOT EDIT. Changes will be discarded."
    };

    for (let queryType of FILE_QUERY_ORDER) {
        let byHash: Record<string, SQL> = {};
        for (let sql of grouped[queryType] || []) {
            const h = sha256();
            h.update(sql.query);
            byHash[h.digest("base64")] = sql;
        }
        ordered[queryType] = byHash;
    }

    let data = JSON.stringify(ordered, null, '\t');
    fs.writeFileSync(whitelistFile, data);
}

const RE_FIRST_WORD = /(?:\s*(?:--.*?$|\/*.*?\*\/))*\s*(\w+)/ms;

function sqlQueryType(sql: SQL): string {
    const keyword = RE_FIRST_WORD.exec(sql.query);
    if (keyword === null) {
        throw Error(`invalid query: ${sql.query}`);
    }
    return keyword[1].toLowerCase();
}